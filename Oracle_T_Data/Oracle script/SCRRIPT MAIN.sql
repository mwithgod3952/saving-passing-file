CREATE TABLE EMP(
    EMP_NO VARCHAR2(30) NOT NULL, 
    EMP_NAME VARCHAR2(80) NOT NULL,
    SALARY NUMBER NULL,
    HIRE_DATE DATE NULL
);

ALTER TABLE EMP ADD CONSTRAINTS FIRST_TEST_EMP_PK PRIMARY KEY(EMP_NO);

ALTER TABLE EMP ADD TEST_COL VARCHAR2(30) DEFAULT '-' NOT NULL;
ALTER TABLE EMP DROP COLUMN TEST_COL;
ALTER TABLE EMP ADD GENDER CHAR(1) CHECK(GENDER IN('T','F')) NULL;
ALTER TABLE EMP DROP COLUMN GENDER;
ALTER TABLE EMP MODIFY EMP_NAME VARCHAR2(100);
ALTER TABLE EMP RENAME COLUMN EMP_NAME TO EMP_NAME3;

ALTER TABLE EMP RENAME COLUMN EMP_NAME3 TO EMP_NAME;
DROP TABLE EMP;

COMENT ON TABLE EMP IS '사원정보';
COMENT ON COLUMN EMP_NO IS '사번';
COMENT ON COLUMN EMP_NAME IS '이름';
COMENT ON COLUMN SALAY IS '사번';
COMENT ON COLUMN HIRE_DATE IS '입사날짜'

-- 참고 : DROP은 테이블을 내부적으로 삭제하는 명령이기 때문에 DESC만으로는 테이블을 읽어드릴 수 없게된다.
DESC DEPT_TABLE;
DROP TABLE EMP;

-- 20,11,18 생성
CREATE TABLE DEPT_TABLE(
    DEPT_NO NUMBER NOT NULL,
    DEPT_NAVER VARCHAR2(50) NOT NULL,
    DEPT_DESC VARCHAR2(100) NULL,
    CREATE_DATE DATE NULL
);    
ALTER TABLE DEPT_TABLE ADD DEPT_DESC1 VARCHAR(80) NULL;
ALTER TABLE DEPT_TABLE DROP COLUMN DEPT_DESC1;
ALTER TABLE DEPT_TABLE ADD CONSTRAINTS DEPT_TEST_PK PRIMARY KEY(DEPT_NO);

-- TEST 2 ONPEN TABLE로 연습
SELECT * FROM EMPLOYEES;
-- 내부적 속성 즉, 정보를 본다는 개념이 큰 것 같다. SELECT랑 구분해서 이해하는 법!!
DESC EMPLOYEES;
-- 1
SELECT EMPLOYEE_ID,FIRST_NAME,LAST_NAME,SALARY FROM EMPLOYEES;
-- 2 
SELECT * FROM EMPLOYEES WHERE EMPLOYEE_ID>100 AND 
JOB_ID='ST_CLERK';

-- 실제로는 employee_id cloumn 에 대한 결과값이지만 alias 를 활용하여 내가 언하는 column 명으로 원하는 값 또는 연산의 결과값을 디스플레이 할 수 있다.
select employee_id emp_no from employees;
select 'A'||'b' first_col,'c'||'d'||'f' second_col from dual;

-- 20.11.23 함수에 대한 
select sysdate from dual;

SELECT SYSDATE
    ,ROUND(SYSDATE, 'YYYY') Years
    ,ROUND(SYSDATE, 'MM') Months
    ,ROUND(SYSDATE, 'DD') Days
    ,ROUND(SYSDATE, 'HH24') Hours
    ,ROUND(SYSDATE, 'MI') Minutes
    ,ROUND(SYSDATE) DFAULT
FROM DUAL; 

-- Self Q / ++ 이 외에도 몇 개 더 만들어 봐야 할 것인데, 기본적으로 DML SELECT 가 조건 절이 없을 때 어떤 스키마 속 COL을 선택한다의 개념이 맞는지 확인 할 필요 있음
-- DML SELECT 와 WHEN OR CALSE 구문을 함게 사용하는 경우에 대해 생각해 볼 필요가 있음( Stack over flow 예제문 살펴볼 것 ) **
SELECT 
    CONCAT(SYSDATE, 'To check the information today') Test_Clolumn 
FROM DUAL;

select * from departments;
select * from Employees;

-- T
SELECT DEPARTMENT_NAME FROM DEPARTMENTS;

/*
CREATE OR REPLACE FUNCTION GET_TEST_FU(RAN_NUM NUMBER)
RETURN VARCHAR2
IS
T_FUNC VARCHAR2(80);
BEGIN
SELECT DEPARTMENT_NAME
INTO T_FUNC
FROM DEPARTMENTS
WHERE department_id = RAN_NUM;

RETURN T_FUNC;
END;
*/

-- 2020.12.07
select * from Titanic;
select * from user_objects;
